# 最大の利益

この問題では、maxv を最大利益とすると、次のアルゴリズムで条件を満たす正しい出力を得ることができます。

```
for j が 1 から n-1 まで
  for i が 0 から j-1 まで
    maxv = (maxv と R[j]-R[i] のうち大きい方)
```

このアルゴリズムは、i<ji<j となるような i と jの全ての組に対する Rj−RiRj−Ri を調べて最大値 maxv を求めています。

ここでひとつ気を付けなければならないことは、maxv の初期値を適切に設定することです。Rt≤109Rt≤109 なので、最大の利益が負になることを考慮して、maxv の初期値は 109×(−1)109×(−1) 以下にする必要があります。あるいは、R1−R0R1−R0 を初期値としてもよいでしょう。

このアルゴリズムでは確かに正しい出力が得られますが、その計算量は O(n2)O(n2) であり、入力の上限 (n≤200,000)n≤200,000) を考慮すると、大きな入力に対しては制限時間内に処理を終えることはできません。そこで、より高速なアルゴリズムを検討しましょう。

知りたい値は jj よりも前方の最小値なのですが、それを上のような素朴なアルゴリズムで求めると O(n)O(n) かかり、これを各 jj について毎回行うと O(n2)O(n2) の計算量になってしまいます。しかしこれは、jj を増やす過程で、それ以前の Rj の最小値（これを minv とします）を保持しておくことで、時刻 jj における最大利益を O(1)O(1) で求めることができます。ここで、O(1)O(1) は入力の大きさに影響しない一定の計算量を表します。

最大利益の更新判定を n 回行えばよいので、次のようなアルゴリズムになります。

```
minv = R[0]
for j が 1 から n-1 まで
  maxv = (maxv と R[j]-minv のうち大きい方)
  minv = (minv と R[j] のうち小さい方)
```

nn に関する２重ループで実装された O(n2)O(n2) の素朴なアルゴリズムを、ひとつのループで完結した O(n)O(n) のアルゴリズムに改良することができました。また、改良したアルゴリズムでは、入力を配列に保持する必要もなくなり、メモリ使用量も改善することができます。



```c++
#include<iostream>
#include<algorithm>

using namespace std;

int main(){
    long long n,r;
    cin>>n;
    long long minv=10000000000;
    long long maxv=-10000000000;
    for(int i=0; i<n; i++){
        cin>>r;
        maxv=max(maxv,r-minv);
        minv=min(minv,r);
    }
    cout<<maxv<<endl;
    return 0;
    
}
```

