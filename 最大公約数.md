# 最大公約数

最大公約数を求める素朴なアルゴリズムは次のようになります。

```
gcd(x, y)
    n = min(x, y)
    for d = n downto 1
        if x と y がともに d で割り切れる
            return d
```

このアルゴリズムは、xx と yy の小さい方を nn とし、dd が nn から 1 までについて、xx と yy の両方を割り切れるかを調べ、割り切れたら dd を返します。

このアルゴリズムは、正しい出力を行いますが最悪 nn 回の割り算を行う必要があるため、大きな数に対しては時間内に出力を得ることはできません。

ユークリッドの互除法は「x≥yx≥y のとき gcd(x,y)gcd(x,y) と gcd(y,xをyで割った余り)gcd(y,xをyで割った余り) は等しい」という定理を用いて xx と yy の最大公約数を高速に求めるアルゴリズムです。

例えば、54 と 20 の最大公約数は以下のように求めることができます。
gcd(54,20)gcd(54,20)
=gcd(20,14)=gcd(20,14)
=gcd(14,6)=gcd(14,6)
=gcd(6,2)=gcd(6,2)
=gcd(2,0)=gcd(2,0)
=2=2

gcd(a,b)gcd(a,b) において、bb が 0 になったときの aa が、与えらえた整数 xx と yy の最大公約数となります。

ここで、このアルゴリズムが正しいことを、aa と bb の公約数と bb と r(ar(a % b)b) の公約数が等しいことを示して確認します。dd を aa と bb の公約数とすると、自然数 ll、mm を用いて a=lda=ld、b=mdb=md と表すことができます。a=bq+ra=bq+r に a=lda=ld を代入し ld=bq+rld=bq+r を得ます。これに、b=mdb=md を代入して、ld=mdq+rld=mdq+r、これをまとめると r=(l−mq)dr=(l−mq)d が得られます。この式は dd が rr の約数であることを示しています。また、dd は bb を割り切るので、dd は bb と rr の公約数になります。一方、同様の方法で、d′d′ が bb と rr の公約数なら d′d′ は aa と bb の公約数であることが分かります。よって aa と bb の公約数の集合と、bb と rr の公約数の集合は等しく、最大公約数も等しくなります。

ユークリッドの互除法のアルゴリズムは次のように実装することができます。

```
gcd(x, y)
    if x < y
        swap(x, y)
    while y > 0
        r = x % y
        x = y
        y = r

    return x
```

ユークリッドの互除法の計算量を見積もってみましょう。例えば、74 と54 に gcd を適用していくと a=bq+ra=bq+r は

74=54×1+20(=r1)74=54×1+20(=r1)
54=20×2+14(=r2)54=20×2+14(=r2)
20=14×1+6(=r3)20=14×1+6(=r3)
14=6×2+2(=r4)14=6×2+2(=r4)
6=2×3+0(=r5)6=2×3+0(=r5)
:

のようになります。ここで gcd を適用して得られる列 b=r1,r2,r3,...b=r1,r2,r3,... がどのように減っていくかを考えます。a=bq+r(0<r<b)a=bq+r(0<r<b) とすると、r<a/2r<a/2 より、ri+2<ri/2ri+2<ri/2 が成り立ちます。このことより、ユークリッドの互除法は多くとも 2log2(b)2log2(b) で完了するので、O(logb)O(logb) と見積もることができます。

```c++
#include<iostream>

using namespace std;

int main(){
    int a,b,r;
    cin>>a>>b;
    if(a<b) swap(a,b);
    while(b>0){
        r = a%b;
        a = b;
        b = r;
    }
    cout<<a<<endl;
    return 0;
}
```

